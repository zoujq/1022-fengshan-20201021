C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\Main.obj
COMPILER INVOKED BY: F:\Keil\C51\BIN\C51.EXE ..\..\User\Main.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Application;..
                    -\..\User\INC;..\..\Libraries;..\..\User\pt_os) DEBUG PRINT(.\List\Main.lst) TABS(2) OBJECT(.\Output\Main.obj)

line level    source

   1          //================================================================================
   2          #define  ALLOCATE_EXTERN
   3          #include "YX23F01CB.h"
   4          #include "YX23F01CB_SYS.h"
   5          #include "YX23F01CB_IO_INIT.h"
   6          #include "YX23F01CB_GeneralKey_Touch_Lib_V1.04\YX23F01CB_GeneralKey_Touch_Lib.h"
   7          #include "YX23F01CB_GeneralKey_Touch_Lib_V1.04\YX23F01CB_GeneralKey_Touch_Filter.h"
   8          #include "YX23F01CB_GeneralKey_Touch_Lib_V1.04\YX23F01CB_GeneralKey_Touch_Multibutton.h"
   9          #include "YX23F01CB_TouchUartDebug_Lib_V1.00\YX23F01CB_TouchUartDebug_Lib_CFG.h"
  10          #include "YX23F01CB_TouchUartDebug_Lib_V1.00\YX23F01CB_TouchUartDebug_Lib.h"
  11          #include "delay.h"
  12          #include <stdio.h>
  13          
  14          #define TK1 1<<15
  15          #define TK2 1<<14
  16          #define TK3 1<<13
  17          #define TK4 1<<12
  18          #define TK5 1<<11
  19          
  20          
  21          extern void init_printf();
  22          void init_ntc_adc();
  23          void init_display();
  24          unsigned int get_ntc_adc();
  25          void  buzzer();
  26          u16 get_temp();
  27          void init_TIMER0();
  28          void key_check();
  29          void display_flash();
  30          //================================================================================
  31          
  32          char display_data1=0;
  33          char display_data2=0;
  34          char display_point=0;
  35          char display_uv=0;
  36          char display_touch_led=0;
  37          u32 yuyue_counter=0;
  38          
  39          u32 counter=0;
  40          
  41          int set_temp=90;
  42          char display_mode=0;
  43          char yuyue_start=0;
  44          
  45          char kid_lock=0;
  46          char led_buff=0;
  47          u16 current_temp=0;
  48          char err_code=0;
  49          char start_work=0;
  50          
  51          char dingshi_start=0;
  52          u32 dingshi_counter=0;
  53          char work_mode=0;
  54          
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 2   

  55          char uv_start=0;
  56          u32 uv_counter=20;
  57          char last_work_mode=0;
  58          u32 count0=0;
  59          u32 jian_ge=0;
  60          //================================================================================
  61          
  62          void set_dingshi_time_plus()
  63          {
  64   1        dingshi_counter+=30;
  65   1        if(dingshi_counter>6*60)
  66   1        {
  67   2          dingshi_counter=30;
  68   2        }
  69   1      }
  70          
  71          void set_dingshi_time_add()
  72          {
  73   1        dingshi_counter+=30;
  74   1        if(dingshi_counter>6*60)
  75   1        {
  76   2          dingshi_counter=6*60;
  77   2        }
  78   1      }
  79          void set_dingshi_time_red()
  80          {
  81   1        if(dingshi_counter>30)
  82   1        {
  83   2          dingshi_counter-=30;
  84   2        }
  85   1      }
  86          
  87          void display_dingshi_set()
  88          {
  89   1        display_data1=dingshi_counter/60;
  90   1        display_data2=(dingshi_counter%60)/6;
  91   1        display_point=1;
  92   1      }
  93          
  94          
  95          void display_dingshi_time()
  96          {
  97   1        static u16 i6=0;
  98   1        display_data1=dingshi_counter/60;
  99   1        display_data2=(dingshi_counter%60)/6;
 100   1        
 101   1        if(i6==1)
 102   1        {
 103   2          display_point=1;
 104   2        } 
 105   1        else if(i6==50)
 106   1        {         
 107   2          display_point=0;          
 108   2        }
 109   1        else if(i6==100)
 110   1        {
 111   2          i6=0;
 112   2        }
 113   1        i6++;
 114   1      }
 115          void display_uv_time()
 116          {
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 3   

 117   1        display_data1=uv_counter/10;
 118   1        display_data2=uv_counter%10;
 119   1        display_point=0;
 120   1      }
 121          
 122          void display_off()
 123          {
 124   1        display_data1=8;
 125   1        display_data2=8;
 126   1        display_point=0;
 127   1      }
 128          
 129          void display_none()
 130          {
 131   1        display_data1='+';
 132   1        display_data2='+';
 133   1        display_point=0;
 134   1      }
 135          void key_check()
 136          {
 137   1        static u16 ON_TK=0;
 138   1        static u16 i3=0;
 139   1        if(TouchKeyFlag )
 140   1        {   
 141   2          if(ON_TK==0)
 142   2          {
 143   3            ON_TK=1;
 144   3            if(work_mode==0)
 145   3            {
 146   4              work_mode=1;
 147   4              dingshi_counter=90;
 148   4      
 149   4            }
 150   3            else
 151   3            {
 152   4              if(dingshi_start==1 || uv_start==1)
 153   4              {
 154   5                work_mode=0;
 155   5                dingshi_counter=0;
 156   5                dingshi_start=0;
 157   5                uv_start=0;
 158   5                uv_counter=0;
 159   5      
 160   5              }
 161   4              else
 162   4              {
 163   5                set_dingshi_time_plus();  
 164   5                display_dingshi_set();          
 165   5              }
 166   4            }
 167   3            count0=0;
 168   3          }
 169   2          
 170   2        }
 171   1        else
 172   1        {
 173   2          ON_TK=0;
 174   2        }
 175   1      
 176   1        if(work_mode==0)
 177   1        {
 178   2          static u16 i5=0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 4   

 179   2          count0=0; 
 180   2          display_off();    
 181   2          if(i5==1)
 182   2          {
 183   3            display_touch_led=0x01;
 184   3          } 
 185   2          else if(i5==60)
 186   2          {         
 187   3            display_touch_led=0x00;         
 188   3          }
 189   2          else if(i5==120)
 190   2          {
 191   3            i5=0;
 192   3          }
 193   2          i5++;
 194   2        }
 195   1        else
 196   1        {
 197   2          display_touch_led=1;
 198   2          if(count0<340)
 199   2          {
 200   3            count0++;
 201   3            if(count0%50==0)
 202   3            {
 203   4              static char i=0;
 204   4              if(i==0)
 205   4              {
 206   5                display_dingshi_set();          
 207   5                i=1;
 208   5              }
 209   4              else
 210   4              {
 211   5                display_none();
 212   5                i=0;
 213   5              }
 214   4              
 215   4            }
 216   3      
 217   3          }
 218   2          else
 219   2          {
 220   3            
 221   3            if(dingshi_counter>0)
 222   3            {
 223   4              
 224   4              dingshi_start=1;
 225   4              display_dingshi_time(); 
 226   4              
 227   4            }
 228   3            else 
 229   3            {
 230   4              dingshi_start=0;
 231   4              if(uv_start==0)
 232   4              {
 233   5                uv_start=1;
 234   5                uv_counter=20;
 235   5              }
 236   4              else if(uv_counter==0)
 237   4              {
 238   5                uv_start=0;
 239   5                work_mode=0;
 240   5                
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 5   

 241   5              }
 242   4              else if(uv_counter>0)
 243   4              {
 244   5                display_uv_time();
 245   5              }
 246   4              
 247   4            }
 248   3          }
 249   2      
 250   2        }
 251   1        
 252   1      
 253   1      }
*** WARNING C280 IN LINE 138 OF ..\..\User\Main.c: 'i3': unreferenced local variable
 254          #define FAN P1_1
 255          #define UV P0_7
 256          #define JIARE P0_3
 257          #define LED1_UV P1_2 
 258          #define LED2_TOUCH P1_3 
 259          
 260          void work_check()
 261          {
 262   1        static char inited=0;
 263   1        static u16 count02=0;
 264   1        if(inited==0)
 265   1        {
 266   2          P1M1=GPIO_Out_PP;//fan
 267   2          P0M7=GPIO_Out_PP;//vu
 268   2          P0M3=GPIO_Out_PP;//jiare
 269   2          P1M2=GPIO_Out_PP;//LED uv 
 270   2          P1M3=GPIO_Out_PP;//LED2_TOUCH
 271   2          
 272   2          inited=1;
 273   2        }
 274   1        
 275   1        if(work_mode==1 )
 276   1        {
 277   2          if(dingshi_start==1)
 278   2          {
 279   3            FAN=1;
 280   3            JIARE=1;
 281   3          }
 282   2          else
 283   2          {
 284   3            FAN=0;
 285   3            JIARE=0;
 286   3          }
 287   2          if(uv_start==1 && uv_counter>0)
 288   2          {
 289   3            if(count02>0)
 290   3            {
 291   4              UV=0;
 292   4            }
 293   3            else
 294   3            {
 295   4              UV=1;
 296   4            }
 297   3            display_uv=1;
 298   3          }
 299   2          else
 300   2          {
 301   3            UV=0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 6   

 302   3            display_uv=0;
 303   3          }
 304   2        }
 305   1        else
 306   1        {
 307   2          FAN=0;
 308   2          JIARE=0;
 309   2          UV=0;
 310   2          display_uv=0;
 311   2          display_off();
 312   2        }
 313   1      
 314   1        if(last_work_mode!=dingshi_start)
 315   1        {
 316   2          
 317   2          if(last_work_mode==1 && dingshi_start==0)
 318   2          {
 319   3            count02++;
 320   3            if(count02<1000)
 321   3            {
 322   4              FAN=1;
 323   4            }
 324   3            else
 325   3            {
 326   4              count02=0;
 327   4              FAN=0;
 328   4              last_work_mode=dingshi_start;
 329   4            }
 330   3          }
 331   2          else
 332   2          {
 333   3            last_work_mode=dingshi_start;
 334   3          }
 335   2        }
 336   1        else
 337   1        {
 338   2          count02=0;
 339   2        }
 340   1        
 341   1      
 342   1      
 343   1      }
 344          
 345          
 346          /***********************************红外解码**************************************/
 347          u8 c_timer=0; 
 348          u8 c_end_flag=0;
 349          u8 c_start_flag=0;
 350          xdata u8 nec_buff[34];
 351          u8 nec_index=0;
 352          xdata u8 nec_data[4];
 353          void init_TIMER0()
 354          {
 355   1        TCON1 = 0x00;           //
 356   1        TMOD = 0x00;            //
 357   1        
 358   1        TH0 = 0xFF;
 359   1        TL0 = 0x7B;             //100us
 360   1        IE |= 0x02;             //
 361   1        TCON |= 0x10;           //
 362   1          
 363   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 7   

 364          
 365          void TIMER0_Rpt(void) interrupt TIMER0_VECTOR  //时基100us
 366          {
 367   1        static u32 tt=0;
 368   1      
 369   1        c_timer++;
 370   1        if(c_timer>150)
 371   1        {
 372   2          c_end_flag=1;
 373   2          c_timer=0;
 374   2        }
 375   1        if(tt++>600000)
 376   1        {
 377   2          tt=0;
 378   2          if(dingshi_counter>0)
 379   2          {
 380   3            if(dingshi_start==1)
 381   3            {
 382   4              dingshi_counter--;      
 383   4            }
 384   3            
 385   3          }
 386   2          if(uv_counter>0)
 387   2          {
 388   3            if(uv_start==1)
 389   3            {
 390   4              uv_counter--;
 391   4            }
 392   3          } 
 393   2        }
 394   1        jian_ge++;
 395   1      } 
 396          void init_exti0()
 397          {
 398   1        P3M5 = 0x69;            //P35设置为带SMT上拉输入
 399   1        PITS4 |= 0x04;          //INT17下降沿  
 400   1        PINTE2 = 0x02;
 401   1        IE2 |= 0x01;              //打开INT17中断
 402   1        
 403   1      }
 404          
 405          void ISR_INT16_17(void)  interrupt INT16_17_VECTOR
 406          {
 407   1        PINTF2 &=~ 0x02;        //清除INT17中断标志位    
 408   1        if(c_start_flag)
 409   1        {
 410   2          if(c_timer>105)
 411   2          {
 412   3            nec_index=0;
 413   3          }
 414   2          nec_buff[nec_index]=c_timer;
 415   2          c_timer=0;
 416   2          nec_index++;
 417   2          if(nec_index>33)
 418   2          {
 419   3            nec_index=0;
 420   3          }
 421   2          c_end_flag=0;
 422   2        }
 423   1        else
 424   1        {
 425   2          c_start_flag=1;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 8   

 426   2          c_timer=0;
 427   2        }
 428   1      }
 429          void chu_li_nec()
 430          {
 431   1        if(nec_data[0]==0 && nec_data[1]==0xff)
 432   1        {
 433   2          if(jian_ge<10000)
 434   2          {
 435   3            return;
 436   3          }
 437   2          jian_ge=0;
 438   2          if(nec_data[2]==0)
 439   2          {
 440   3            if(work_mode==0)
 441   3            {
 442   4              work_mode=1;
 443   4              dingshi_counter=90;
 444   4            }
 445   3            else
 446   3            {
 447   4              work_mode=0;
 448   4              dingshi_counter=0;
 449   4              dingshi_start=0;
 450   4              uv_start=0;
 451   4              uv_counter=0;
 452   4            }
 453   3          }
 454   2          else if(work_mode==1 && uv_start==0)
 455   2          {
 456   3            if(nec_data[2]==0x08)//
 457   3            {
 458   4                        
 459   4              set_dingshi_time_add();       
 460   4              count0=0;
 461   4            }
 462   3            else if(nec_data[2]==0x0A)//
 463   3            {
 464   4                
 465   4              set_dingshi_time_red();       
 466   4              count0=0;
 467   4            }
 468   3            
 469   3          }
 470   2          if(nec_data[2]==0x02)//uv
 471   2          {
 472   3              if(uv_start==0)
 473   3              {
 474   4                work_mode=1;
 475   4                uv_start=1;
 476   4                uv_counter=20;
 477   4                dingshi_counter=0;
 478   4                dingshi_start=0;
 479   4              }
 480   3              else
 481   3              {         
 482   4                work_mode=0;
 483   4                dingshi_counter=0;
 484   4                dingshi_start=0;
 485   4                uv_start=0;
 486   4                uv_counter=0;
 487   4              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 9   

 488   3              
 489   3            }
 490   2        }
 491   1        
 492   1      }
 493          extern char putchar (char c);
 494          void decode_nec()
 495          {
 496   1        if(nec_index && c_end_flag)
 497   1        {
 498   2          nec_data[0]=(nec_buff[1]<0x0F ? 0 : 1)<<0 |
 499   2                (nec_buff[2]<0x0F ? 0 : 1)<<1 |
 500   2                (nec_buff[3]<0x0F ? 0 : 1)<<2 |
 501   2                (nec_buff[4]<0x0F ? 0 : 1)<<3 |
 502   2                (nec_buff[5]<0x0F ? 0 : 1)<<4 |
 503   2                (nec_buff[6]<0x0F ? 0 : 1)<<5 |
 504   2                (nec_buff[7]<0x0F ? 0 : 1)<<6 |
 505   2                (nec_buff[8]<0x0F ? 0 : 1)<<7 ;
 506   2          nec_data[1]=(nec_buff[9]<0x0F ? 0 : 1)<<0 |
 507   2                (nec_buff[10]<0x0F ? 0 : 1)<<1 |
 508   2                (nec_buff[11]<0x0F ? 0 : 1)<<2 |
 509   2                (nec_buff[12]<0x0F ? 0 : 1)<<3 |
 510   2                (nec_buff[13]<0x0F ? 0 : 1)<<4 |
 511   2                (nec_buff[14]<0x0F ? 0 : 1)<<5 |
 512   2                (nec_buff[15]<0x0F ? 0 : 1)<<6 |
 513   2                (nec_buff[16]<0x0F ? 0 : 1)<<7 ;
 514   2          nec_data[2]=(nec_buff[17]<0x0F ? 0 : 1)<<0 |
 515   2                (nec_buff[18]<0x0F ? 0 : 1)<<1 |
 516   2                (nec_buff[19]<0x0F ? 0 : 1)<<2 |
 517   2                (nec_buff[20]<0x0F ? 0 : 1)<<3 |
 518   2                (nec_buff[21]<0x0F ? 0 : 1)<<4 |
 519   2                (nec_buff[22]<0x0F ? 0 : 1)<<5 |
 520   2                (nec_buff[23]<0x0F ? 0 : 1)<<6 |
 521   2                (nec_buff[24]<0x0F ? 0 : 1)<<7 ;
 522   2          nec_data[3]=(nec_buff[25]<0x0F ? 0 : 1)<<0 |
 523   2                (nec_buff[26]<0x0F ? 0 : 1)<<1 |
 524   2                (nec_buff[27]<0x0F ? 0 : 1)<<2 |
 525   2                (nec_buff[28]<0x0F ? 0 : 1)<<3 |
 526   2                (nec_buff[29]<0x0F ? 0 : 1)<<4 |
 527   2                (nec_buff[30]<0x0F ? 0 : 1)<<5 |
 528   2                (nec_buff[31]<0x0F ? 0 : 1)<<6 |
 529   2                (nec_buff[32]<0x0F ? 0 : 1)<<7 ;
 530   2          nec_index=0;
 531   2          chu_li_nec();
 532   2          
 533   2      //    putchar(nec_data[0]);
 534   2      //    putchar(nec_data[1]);
 535   2      //    putchar(nec_data[2]);
 536   2      //    putchar(nec_data[3]);
 537   2          
 538   2          nec_data[0]=0;
 539   2          nec_data[1]=0;
 540   2          nec_data[2]=0;
 541   2          nec_data[3]=0;
 542   2        }
 543   1      }
 544          
 545          
 546          void main()
 547          {
 548   1        
 549   1        SystemInit();           //
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 10  

 550   1        //init_printf();
 551   1        init_display();
 552   1        init_TIMER0();
 553   1        init_exti0();
 554   1        EA = 1;
 555   1        CTK_Init(); 
 556   1                    
 557   1      
 558   1        //printf("start\n\r");  
 559   1        while(1)
 560   1        {
 561   2      
 562   2          if(OneCycleScanDone)
 563   2          {
 564   3            TouchRawDataFilter();   //
 565   3            Touch_Signal_Handle();
 566   3            TouchMultibuttonHandle(); //
 567   3            OneCycleScanDone = 0;
 568   3      
 569   3          }
 570   2          
 571   2          key_check();
 572   2          decode_nec();
 573   2          Delay_ms(5);
 574   2          counter++;
 575   2          display_flash();
 576   2          work_check();
 577   2      
 578   2        } 
 579   1      }
 580          
 581          
 582          
 583          
 584          
 585          /*************************************ADC************************************************/
 586          //0~119℃
 587          u16 code Temp_Table[1]={1
 588          
 589          };
 590          
 591          void init_ntc_adc()
 592          {
 593   1        
 594   1        P0M2 = 0x01;                //
 595   1        ADCC0 = 0x80;           //
 596   1        Delay_50us(1);            //
 597   1        ADCC1 = 2;            //
 598   1        ADCC2 = 0x4B;           //  
 599   1      }
 600          unsigned int get_ntc_adc()
 601          {
 602   1        ADCC0 |= 0x40;          //
 603   1        while(!(ADCC0&0x20));     //
 604   1        ADCC0 &=~ 0x20;         //
 605   1        return ADCR;
 606   1      }
 607          
 608          u16 get_temp()
 609          {
 610   1        u16 n=0;
 611   1        u16 ntc_adc=get_ntc_adc();
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 11  

 612   1        
 613   1        for(n=0;n<120;n++)
 614   1        {
 615   2          if(Temp_Table[n]<ntc_adc)
 616   2          {
 617   3            break;
 618   3          }
 619   2        }
 620   1        // printf(" :%d,wen_du:%d\n", ntc_adc,n);
 621   1        if(ntc_adc==0)
 622   1        {
 623   2          err_code=2;
 624   2        }
 625   1        else if(ntc_adc==4095)
 626   1        {
 627   2          err_code=1;
 628   2        }
 629   1      
 630   1        return n;
 631   1      
 632   1      }
 633          
 634          
 635          /***************************************************************************/
 636          //
 637          //#define DISPLAY_A P2_5  P2_1
 638          //#define DISPLAY_B P2_4  P3_4
 639          //#define DISPLAY_C P2_2  P1_4
 640          //#define DISPLAY_D P2_3  P2_4
 641          //#define DISPLAY_E P2_1  P2_5
 642          //#define DISPLAY_F P1_4  P2_2
 643          //#define DISPLAY_G P3_4  P2_3
 644          
 645          #define DISPLAY_A  P2_1
 646          #define DISPLAY_B  P3_4
 647          #define DISPLAY_C  P2_4
 648          #define DISPLAY_D  P2_5
 649          #define DISPLAY_E  P0_2
 650          #define DISPLAY_F  P2_2
 651          #define DISPLAY_G  P2_3
 652          #define DISPLAY_DP P2_0
 653          
 654          //
 655          #define DISPLAY_COM1 P1_6
 656          #define DISPLAY_COM2 P1_5
 657          
 658          
 659          
 660          void init_display()
 661          {
 662   1        P2M1=GPIO_Out_PP;
 663   1        P3M4=GPIO_Out_PP;
 664   1        P2M4=GPIO_Out_PP;
 665   1        P2M5=GPIO_Out_PP;
 666   1        P0M2=GPIO_Out_PP;
 667   1        P2M2=GPIO_Out_PP;
 668   1        P2M3=GPIO_Out_PP;
 669   1        P2M0=GPIO_Out_PP;
 670   1        
 671   1        P1M6=GPIO_Out_PP;
 672   1        P1M5=GPIO_Out_PP;
 673   1      
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 12  

 674   1        //display_off();
 675   1        DISPLAY_A=0;
 676   1        DISPLAY_B=0;
 677   1        DISPLAY_C=0;
 678   1        DISPLAY_D=0;
 679   1        DISPLAY_E=0;
 680   1        DISPLAY_F=0;
 681   1        DISPLAY_G=0;
 682   1        DISPLAY_DP=0;
 683   1      
 684   1        DISPLAY_COM1=1;
 685   1        DISPLAY_COM2=1;
 686   1      
 687   1      }
 688          void display_close()
 689          {
 690   1        DISPLAY_A=0;
 691   1        DISPLAY_B=0;
 692   1        DISPLAY_C=0;
 693   1        DISPLAY_D=0;
 694   1        DISPLAY_E=0;
 695   1        DISPLAY_F=0;
 696   1        DISPLAY_G=0;
 697   1        DISPLAY_DP=0;
 698   1        DISPLAY_COM1=1;
 699   1        DISPLAY_COM2=1;
 700   1      
 701   1      }
 702          
 703          
 704          void display_1(char c,char b)
 705          {
 706   1      //  display_point
 707   1        
 708   1        
 709   1        DISPLAY_COM1=1;
 710   1        DISPLAY_COM2=1;
 711   1        
 712   1        switch(c)
 713   1        {
 714   2          case 0:
 715   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=0;
 716   2            break;
 717   2          case 1:
 718   2            DISPLAY_A=0;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=0;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=0;
 719   2            break;
 720   2          case 2:
 721   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=0;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=0;  DISPLAY_G=1;
 722   2            break;
 723   2          case 3:
 724   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=1;
 725   2            break;
 726   2          case 4:
 727   2            DISPLAY_A=0;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=0;  DISPLAY_E=0;  DISPLAY_F=1;  DISPLAY_G=1;
 728   2            break;
 729   2          case 5:
 730   2            DISPLAY_A=1;  DISPLAY_B=0;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=1;  DISPLAY_G=1;
 731   2            break;
 732   2          case 6:
 733   2            DISPLAY_A=1;  DISPLAY_B=0;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=1;
 734   2            break;
 735   2          case 7:
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 13  

 736   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=0;
 737   2            break;
 738   2          case 8:
 739   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=0;
 740   2            break;
 741   2          case 9:
 742   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=1;  DISPLAY_G=1;
 743   2            break;
 744   2          default:
 745   2            DISPLAY_A=0;  DISPLAY_B=0;  DISPLAY_C=0;  DISPLAY_D=0;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=0;
 746   2            break;
 747   2          
 748   2        }
 749   1        if(b==1)
 750   1        {
 751   2          DISPLAY_COM1=0;
 752   2          DISPLAY_COM2=1;
 753   2        }
 754   1        else if(b==2)
 755   1        {
 756   2          DISPLAY_COM1=1;
 757   2          DISPLAY_COM2=0;
 758   2        }
 759   1        
 760   1        if(display_point)
 761   1        {
 762   2            DISPLAY_DP=1;
 763   2        }
 764   1        else
 765   1        {
 766   2            DISPLAY_DP=0;
 767   2        }
 768   1      }
 769          void display_uv_(char c)
 770          {
 771   1        if(c)
 772   1        {
 773   2          LED1_UV=1;
 774   2        }
 775   1        else
 776   1        {
 777   2          LED1_UV=0;
 778   2        }
 779   1      }
 780          void display_touch_(char c)
 781          {
 782   1        if(c)
 783   1        {
 784   2          LED2_TOUCH=1;
 785   2        }
 786   1        else
 787   1        {
 788   2          LED2_TOUCH=0;
 789   2        }
 790   1      }
 791          void display_flash()
 792          {
 793   1      
 794   1        display_1(1,2);
 795   1        display_1(display_data1,1);
 796   1        Delay_ms(5);
 797   1        display_1(display_data2,2);
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 14  

 798   1        display_uv_(display_uv);
 799   1        display_touch_(display_touch_led);
 800   1      }
 801          
 802          void  buzzer()
 803          {
 804   1        static char inited=0;
 805   1        int i=0;
 806   1        if(inited==0)
 807   1        {
 808   2          P0M3 = 0xC2;                        //P03设置为推挽输出
 809   2          PWM3_MAP = 0x03;          //PWM3映射P03口
 810   2          PWM3P = 0x20;           //PWM周期为0xFF
 811   2          PWM3D = 0x10;           //PWM占空比设置
 812   2          PWM3C = 0x97;             //使能PWM3，关闭中断，允许输出，时钟4分频
 813   2          inited=1;
 814   2        } 
 815   1        PWM3C = 0x97; 
 816   1        Delay_ms(200);
 817   1        PWM3C = 0x07;
 818   1        
 819   1        
 820   1      }
 821          
 822          //void init
 823          /*********************************END OF FILE************************************/
 824          
 825          
 826          
 827          
 828          
 829          
 830          
 831          
 832          
 833          
 834          
 835          
 836          
 837          
 838          
 839          
 840          
 841          
 842          
 843          
 844          
 845          
 846          
 847          
 848          
 849          
 850          
 851          
 852          
 853          
 854          
 855          
 856          
 857          
 858          
 859          
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2020 10:18:56 PAGE 15  

 860          
 861          
 862          
 863          
 864          
 865          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2667    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =     38    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     64       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
